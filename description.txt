Реализовать игру «Крестики-Нолики»:

игровое поле — 3х3 клетки;
над полем информация — чей текущий ход (крестика или нолика) / информация о победе одной из сторон или ничья;
при клике на клетку в ней должен отрисовываться символ стороны, у которой был текущий ход (крестик или нолик);
если 3 одинаковых символа размещается в одну линию (горизонтально, вертикально или по диагонали), то остановить игру и сообщить о победе крестика или нолика;
реализовать кнопку «Начать заново», при клике на которую поле будет очищаться и игра начнётся сначала;
дизайн на усмотрение разработчика.

План реализации:

1. Подготовьте компоненты. В проекте создайте следующие компоненты (пока пустые):

Field — будет игровым полем с клетками, где каждая клетка представляет из себя кнопку. При нажатии на определенную клетку будет происходить ход одной из сторон;
Information — будет выводить, чей на данный момент ход (крестика или нолика), либо информацию о победе одной из сторон;
Game (или App) — корневой компонент. Будет выводить компоненты Information, Field, а также кнопку «Начать заново».
Каждый из этих компонентов является stateful-контейнером, который внутри содержит stateless-шаблон.
То есть компонент Field (или их можно называть по типу FieldContainer) является компонентом-контейнером, который внутри выводит компонент-шаблон FieldLayout.
Аналогично Information выводит InformationLayout,
Game выводит GameLayout.

Внутри компонентов-шаблонов (GameLayout, InformationLayout, FieldLayout) подготовьте всю верстку игры (в статичном виде, без функционала). При необходимости для компонентов создавайте CSS-модули, они будут отдельными для каждого компонента.

2. Подготовьте состояния. В корневом компоненте Game создаем следующие состояния:

currentPlayer — кто ходит в данный момент, значениями может быть 'X' или '0'. По умолчанию — 'X';
isGameEnded — была ли завершена игра. По умолчанию false;
isDraw — была ли ничья. По умолчанию false;
field — массив клеток игрового поля, состоящий из 9 пустых строк (3x3).

3.Напишите логику игры.

При клике на клетку устанавливайте символ ходившего игрока (currentPlayer) в выбранную ячейку массива field (при условии, что выбранная ячейка пуста и игра не завершена).

Кроме того, при клике на ячейку необходимо определять, выиграл ли кто-то после выполненного хода.
 Могут быть следующие ситуации:

Если кто-то выиграл — устанавливаем в isGameEnded значение true;
Если победителей нет и нет пустых ячеек — устанавливаем в isDraw значение true (ничья);
Если победителей нет и есть пустые ячейки — устанавливаем в currentPlayer игрока, который будет следующим совершать ход (currentPlayer === 'X' ? '0' : 'X’).

Для того чтобы определить, кто является победителем, мы можем сравнить field с заранее определенными вариантами побед:
const WIN_PATTERNS = [
  [0, 1, 2], [3, 4, 5], [6, 7, 8], // Варианты побед по горизонтали
  [0, 3, 6], [1, 4, 7], [2, 5, 8], // Варианты побед по вертикали
  [0, 4, 8], [2, 4, 6] // Варианты побед по диагонали
];
Если массив field содержит один из вариантов побед (когда одинаковый символ игрока стоит на победных индексах), то игра завершается и данный игрок считается победителем. Например, если field[1], field[4], field[7] равны 'X', то это будет считаться победой 'X'.

Для проверки массивов можно использовать цикл for или встроенные методы массивов (some(), every() и т. д.).
При клике на кнопку «Начать заново» для состояний currentPlayer, isGameEnded, isDraw, field устанавливаем начальные значения.
_____________________________________
метод some()

** JavaScript метод some() позволяет проверить соответствует ли по крайней мере один элемент в массиве условию, заданному в передаваемой функции.

Возвращаемое значение метода будет логическое значение true, если функция обратного вызова возвращает значение true (найден элемент который соответствует заданному условию), в противном случае вернет логическое значение false (все элементы массива не соответствуют переданному условию).

NB! функция обратного вызова, переданная в качестве параметра метода some() не будет вызвана для удалённых, или пропущенных элементов массива.
NB! Метод some() не изменяет массив для которого он был вызван.

Диапазон элементов, обрабатываемых с помощью метода some() устанавливается перед первым вызовом функции обратного вызова. Если элементы были добавлены к массиву после её вызова, то на таких элементах функция вызвана не будет.

Если значения существующих элементов массива изменяются в момент выполнения, то в качестве передаваемого значения функции будет значение в тот момент времени, когда метод some() посещает их. Если элементы удаляются до их посещения, то такие элементы посещены не будут.

JavaScript синтаксис:
// только с callback функцией
array.some( function( currentValue, index, arr ) );

// с использованием объекта, на который может ссылаться ключевое слово this
array.some( function( currentValue, index, arr ), thisValue );


function : 	Функция обратного вызова, которая будет выполнена один раз для каждого элемента в массиве до тех пор, пока не найдет такой элемент, для которого вернет истинное значение. Функция принимает следующие параметры:
currentValue - значение текущего элемента
index - индекс массива текущего элемента.
arr - массив, к которому принадлежит текущий элемент (по которому происходит проход).
Обязательный параметр.

thisValue :	Объект, на который может ссылаться ключевое слово this внутри функции обратного вызова. Если параметр thisValue не используется, то в качестве значения this будет использоваться undefined (в конечном счете this будет зависеть от обычных правил контекста выполнения функции). Необязательный параметр.
-------------------------------------------

